.data
memA: .float 200307.21
memB: .float 157202.5
memS: .float 0 # переменная для записи значения числа S

esp: .float 1.0e-15 # точность вычисления SIN
pi2: .float 6.283185307 # pi*2

border: .float 10.0 # крайнее значение для memB, используется для условия вычисленя тождественного memB
dop: .float 0.5 # понадобится при вычислении числа S

h1: .asciiz "\n"
mes_sin: .asciiz "sin(B) = "
mes_A: .asciiz "A = "
mes_B: .asciiz "B = "
mes_S: .asciiz "S = "

mes_res: .asciiz "\nResult: "
mes_equal: .asciiz "number A is equal to number S\n"
mes_less: .asciiz "number A is less then number S\n"
mes_greater: .asciiz "number A is greater then number S\n"

.text

#------------------------------------------ вычисление SIN(memB) --------------------------------------------#
SIN:
	# для корректного вычисления синуса, при необходимости 
	# преобразуем большое число memB в меньшее ему тождественное 
	# используем правило sin(B) = sin(B - 2*pi*k), где k - целое число
	
	lwc1 $f0, memB # помещаем memB в регистр f0
	lwc1 $f1, border 
	c.lt.s $f1, $f0 # производим сравнение
	bc1t FindEqual # при большом memB переходим к определению тождественного ему числа
	
Continue: # переход к началу вычисления sin(memB)	
	li $t0, 1 # счетчик n = 1
	lwc1 $f1, esp
	mov.s $f2, $f0 # здесь храним актуальный член ряда r, r_0 = x = memB
	
	la $a0, mes_sin # помещаем в регистр сообщение mes_sin
	li $v0, 4
	syscall # выводим на сообщение экран
	
Loop:
	abs.s $f3, $f2 # берём модуль от члена ряда и записываем его в f3
	c.lt.s $f3, $f1 # сверяем член ряда с минимальной точностью
	bc1t LabTask # если член ряда по-прежнему больше нужной точности, цикл продолжится
	
	add.s $f12, $f12, $f2 # добавляем к общей сумме член ряда
	add $t0, $t0, 2 # увеличиваем степень n на 2
	
	sub $t1, $t0, 1 # вычитаем из степени 1 и результат сохраняем в $t1
	mul $t1, $t1, $t0 # рассчитываем произведение n*(n-1)
	mtc1 $t1, $f4 # помещаем содержимое из $t1 в $f4
	cvt.s.w $f4, $f4 # переводим целое число n*(n-1) в ЧПЗ
	
	div.s $f4, $f0, $f4 # делим x/(n*(n-1))
	mul.s $f4, $f4, $f0 # умножаем результат на x
	neg.s $f4, $f4 # домножаем результат на (-1)
	mul.s $f2, $f2, $f4 # умножаем полученное на предыдущий член ряда
	
	# в результате получаем, что f2 = -r*x*x/(n*(n-1))
	
	j Loop # возвращаемся к началу цикла

FindEqual:
	lwc1 $f1, pi2 # записываем в регистр константу pi*2
	div.s $f2, $f0, $f1 # делим memB/(pi*2) и запоминаем результат в f2
	
	# теперь нужно округлить полученное число вниз
	# для этого проще конвертировать float в int, отбросив дробную часть
	
	cvt.w.s $f2, $f2 # преобразуем f2 в целое число и перезаписываем его в f2
	cvt.s.w $f2, $f2 # переводим целое число обратно в ЧПЗ
	
	mul.s $f1, $f1, $f2 # перезаписываем в f1 произведение от (2*pi) на их рассчитанное целое кол-во
	sub.s $f0, $f0, $f1 # вычитаем из memB полученное число и записываем результат. Это и есть наименьшее тождественное число
	
	j Continue

#--------------------------------------- начало выполнения задачи ЛР3 -----------------------------------------#
LabTask:	
	li, $v0, 2
	syscall # выводим на экран содержимое регистра f12 = sin(B)
	
	la $a0, h1
	li, $v0, 4
	syscall # производим перенос строки (выводим сообщение "\n")
	
	# теперь рассчитываем S = A + 0.5 - sin(B)
	# memA будем хранить в регистре f0
	# dop = 0.5 будем хранить в f1
	# значение sin(B) будем по-прежнему использовать из регистра f12
	
	lwc1 $f0, memA
	lwc1 $f1, dop
	add.s $f2, $f0, $f1
	sub.s $f2, $f2, $f12
	swc1 $f2, memS # записываем результат в переменную memS

#------------------------------------- выводим значения чисел A, B и S -----------------------------------------#	
	la $a0, mes_A
	li, $v0, 4
	syscall # выводим на экран сообщение mes_A
	mov.s $f12, $f0 # записываем в f12 значение числа A
	li, $v0, 2
	syscall # выводим на экран содержимое регистра f12 = sin(B)
	la $a0, h1
	li, $v0, 4
	syscall # производим перенос строки (выводим сообщение "\n")
	
	la $a0, mes_B
	li, $v0, 4
	syscall # выводим на экран сообщение mes_B
	lwc1 $f12, memB # записываем в f12 значение числа B
	li, $v0, 2
	syscall # выводим на экран содержимое регистра f12 = B
	la $a0, h1
	li, $v0, 4
	syscall # производим перенос строки (выводим сообщение "\n")	
	
	la $a0, mes_S
	li, $v0, 4
	syscall # выводим на экран сообщение mes_S
	lwc1 $f12, memS # записываем в f12 значение числа S
	li, $v0, 2
	syscall # выводим на экран содержимое регистра f12 = S
	la $a0, h1
	li, $v0, 4
	syscall # производим перенос строки (выводим сообщение "\n")
	
#---------------------------------- здесь производим сравнения чисел A и S -------------------------------------#	
	la $a0, mes_res
	li, $v0, 4
	syscall
	
	# memA хранится в $f0
	# memS по-прежнему находится в $f12 и в $f2
	c.eq.s $f0, $f12
	bc1t Equal
	c.lt.s $f0, $f12
	bc1t Less
	
Greater:
	la $a0, mes_greater
	li, $v0, 4
	syscall
	j Exit

Equal:
	la $a0, mes_equal
	li, $v0, 4
	syscall
	j Exit
	
Less:
	la $a0, mes_less
	li, $v0, 4
	syscall
	
Exit:	
	li, $v0, 10
	syscall # завершаем программу
